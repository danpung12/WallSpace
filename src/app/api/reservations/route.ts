import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

/**
 * GET /api/reservations
 * ÏÇ¨Ïö©ÏûêÏùò ÏòàÏïΩ Î™©Î°ù Ï°∞Ìöå
 * Query params:
 *   - status: 'pending' | 'confirmed' | 'completed' | 'cancelled'
 *   - location_id: ÌäπÏ†ï Ïû•ÏÜåÏùò ÏòàÏïΩÎßå Ï°∞Ìöå
 */
export async function GET(request: NextRequest) {
  try {
    console.log('üîç GET /api/reservations - Starting...');
    const supabase = await createClient();
    
    // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©Ïûê ÌôïÏù∏
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.error('‚ùå Auth error:', authError);
      return NextResponse.json(
        { error: 'Unauthorized' }, 
        { status: 401 }
      );
    }

    console.log('‚úÖ User authenticated:', user.id);

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const status = searchParams.get('status');
    const locationId = searchParams.get('location_id');
    const spaceId = searchParams.get('space_id');
    console.log('üìä Query params:', { id, status, locationId, spaceId });

    // ÌäπÏ†ï ÏòàÏïΩ IDÎ°ú Ï°∞Ìöå
    if (id) {
      console.log('üîç Fetching single reservation:', id);
      const { data: reservation, error: reservationError } = await supabase
        .from('reservations')
        .select(`
          *,
          location:locations(*, images:location_images(image_url)),
          space:spaces(*),
          artwork:artworks(*),
          artist:profiles!reservations_artist_id_fkey(id, name, nickname, phone, email, avatar_url)
        `)
        .eq('id', id)
        .single();

      if (reservationError) {
        console.error('‚ùå Error fetching reservation:', reservationError);
        return NextResponse.json(
          { error: 'Failed to fetch reservation', details: reservationError.message },
          { status: 500 }
        );
      }

      if (!reservation) {
        return NextResponse.json(
          { error: 'Reservation not found' },
          { status: 404 }
        );
      }

      // Í∂åÌïú ÌôïÏù∏: ÏòàÏïΩÌïú ÏûëÍ∞Ä Î≥∏Ïù∏Ïù¥Í±∞ÎÇò Ïû•ÏÜå Í¥ÄÎ¶¨ÏûêÏù∏ Í≤ΩÏö∞Îßå Ï°∞Ìöå Í∞ÄÎä•
      const isArtist = reservation.artist_id === user.id;
      const isManager = (reservation as any).location?.manager_id === user.id;

      if (!isArtist && !isManager) {
        console.log('‚ùå Unauthorized access attempt:', { userId: user.id, artistId: reservation.artist_id, managerId: (reservation as any).location?.manager_id });
        return NextResponse.json(
          { error: 'Unauthorized to view this reservation' },
          { status: 403 }
        );
      }

      // Location Ïù¥ÎØ∏ÏßÄÎ•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
      if ((reservation as any).location?.images) {
        (reservation as any).location.images = ((reservation as any).location.images as any[]).map(img => img.image_url);
      }

      console.log('‚úÖ Reservation fetched:', reservation?.id);
      return NextResponse.json(reservation);
    }

    // ÏòàÏïΩ Ï°∞Ìöå ÏøºÎ¶¨ Íµ¨ÏÑ± (Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞ JOINÏúºÎ°ú Ìïú Î≤àÏóê Ï°∞Ìöå)
    console.log('üîç Fetching reservations...');
    let query = supabase
      .from('reservations')
      .select(`
        *,
        location:locations(
          *,
          images:location_images(image_url)
        ),
        space:spaces(*),
        artwork:artworks(*),
        artist:profiles!reservations_artist_id_fkey(id, name, nickname, phone, email, avatar_url)
      `);

    // location_idÎ°ú Ï°∞ÌöåÌï† Îïå (ÏÇ¨Ïû•ÎãòÏù¥ ÏûêÍ∏∞ Í∞ÄÍ≤åÏùò Î™®Îì† ÏòàÏïΩ Ï°∞Ìöå)
    if (locationId) {
      console.log('üè™ Fetching by location_id (manager view):', locationId);
      // ÏÇ¨Ïû•Îãò Í∂åÌïú ÌôïÏù∏
      const { data: location } = await supabase
        .from('locations')
        .select('manager_id')
        .eq('id', locationId)
        .single();
      
      if (location && location.manager_id === user.id) {
        console.log('‚úÖ Manager authorized for this location');
        query = query.eq('location_id', locationId);
      } else {
        console.log('‚ùå Manager not authorized for this location');
        return NextResponse.json(
          { error: 'Unauthorized to view this location reservations' },
          { status: 403 }
        );
      }
    }
    // space_idÎ°ú Ï°∞ÌöåÌï† Îïå (ÏÇ¨Ïû•ÎãòÏù¥ ÌäπÏ†ï Í≥µÍ∞ÑÏùò ÏòàÏïΩ Ï°∞Ìöå)
    else if (spaceId) {
      console.log('üè™ Fetching by space_id (manager view):', spaceId);
      // ÏÇ¨Ïû•Îãò Í∂åÌïú ÌôïÏù∏: Ìï¥Îãπ Í≥µÍ∞ÑÏù¥ ÏûêÏã†Ïùò locationÏóê ÏÜçÌïòÎäîÏßÄ Ï≤¥ÌÅ¨
      const { data: space } = await supabase
        .from('spaces')
        .select('location_id, locations(manager_id)')
        .eq('id', spaceId)
        .single();
      
      if (space && (space as any).locations?.manager_id === user.id) {
        console.log('‚úÖ Manager authorized for this space');
        query = query.eq('space_id', spaceId);
      } else {
        console.log('‚ùå Manager not authorized for this space');
        return NextResponse.json(
          { error: 'Unauthorized to view this space reservations' },
          { status: 403 }
        );
      }
    } else {
      // ÏùºÎ∞ò Ï°∞Ìöå (ÏûëÍ∞ÄÍ∞Ä ÏûêÏã†Ïùò ÏòàÏïΩ Ï°∞Ìöå)
      query = query.eq('artist_id', user.id);
    }

    query = query.order('created_at', { ascending: false });

    // ÌïÑÌÑ∞ Ï†ÅÏö©
    if (status) {
      query = query.eq('status', status);
    }

    const { data: reservations, error: reservationsError } = await query;

    if (reservationsError) {
      console.error('‚ùå Error fetching reservations:', reservationsError);
      return NextResponse.json(
        { error: 'Failed to fetch reservations', details: reservationsError.message },
        { status: 500 }
      );
    }

    console.log('‚úÖ Reservations fetched:', reservations?.length || 0);
    console.log('üìä Reservations summary:', reservations?.map(r => ({
      id: r.id.substring(0, 8),
      status: r.status,
      start_date: r.start_date,
      end_date: r.end_date
    })));

    // ‚ö° JOINÏúºÎ°ú Ïù¥ÎØ∏ Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôîÏúºÎØÄÎ°ú Ï∂îÍ∞Ä Ï≤òÎ¶¨Îßå ÏàòÌñâ
    if (reservations && reservations.length > 0) {
      for (const reservation of reservations) {
        // Location Ïù¥ÎØ∏ÏßÄÎ•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
        if ((reservation as any).location?.images) {
          (reservation as any).location.images = ((reservation as any).location.images as any[]).map(img => img.image_url);
        }
      }
      console.log('‚úÖ Reservations data processed');
    }

    return NextResponse.json(reservations);

  } catch (error) {
    console.error('‚ùå GET /api/reservations error:', error);
    console.error('Error details:', {
      message: (error as Error).message,
      stack: (error as Error).stack,
    });
    return NextResponse.json(
      { error: 'Internal server error', details: (error as Error).message },
      { status: 500 }
    );
  }
}

/**
 * POST /api/reservations
 * ÏÉà ÏòàÏïΩ ÏÉùÏÑ±
 * Body: {
 *   location_id: string,
 *   space_id: string,
 *   artwork_id: string,
 *   start_date: string (YYYY-MM-DD),
 *   end_date: string (YYYY-MM-DD)
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    
    // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©Ïûê ÌôïÏù∏
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' }, 
        { status: 401 }
      );
    }

    // ÏÇ¨Ïö©Ïûê ÌÉÄÏûÖ ÌôïÏù∏ (ÏûëÍ∞Ä ÎòêÎäî Îß§ÎãàÏ†ÄÎßå ÏòàÏïΩ Í∞ÄÎä•)
    const { data: profile } = await supabase
      .from('profiles')
      .select('user_type')
      .eq('id', user.id)
      .single();

    if (!profile || !['artist', 'manager'].includes(profile.user_type)) {
      return NextResponse.json(
        { error: 'Only artists or managers can make reservations' },
        { status: 403 }
      );
    }

    // ÏöîÏ≤≠ Î≥∏Î¨∏ ÌååÏã±
    const body = await request.json();
    console.log('üì¶ Received reservation data:', body);
    const { location_id, space_id, artwork_id, start_date, end_date } = body;

    // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    if (!location_id || !space_id || !artwork_id || !start_date || !end_date) {
      console.error('‚ùå Missing fields:', { location_id, space_id, artwork_id, start_date, end_date });
      return NextResponse.json(
        { error: 'Missing required fields: location_id, space_id, artwork_id, start_date, end_date' },
        { status: 400 }
      );
    }

    // ÎÇ†Ïßú Í≤ÄÏ¶ù
    const startDate = new Date(start_date);
    const endDate = new Date(end_date);
    if (startDate >= endDate) {
      return NextResponse.json(
        { error: 'end_date must be after start_date' },
        { status: 400 }
      );
    }

    // Í≥µÍ∞Ñ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (Í∞ÄÍ≤© Í≥ÑÏÇ∞Ïö©)
    console.log('üîç Fetching space:', space_id);
    const { data: space, error: spaceError } = await supabase
      .from('spaces')
      .select('price')
      .eq('id', space_id)
      .single();

    if (spaceError || !space) {
      console.error('‚ùå Space not found:', spaceError);
      return NextResponse.json(
        { error: 'Space not found', details: spaceError?.message },
        { status: 404 }
      );
    }
    console.log('‚úÖ Space found:', space);

    // ÎÇ†Ïßú Ï§ëÎ≥µ ÌôïÏù∏ (Ïã§Ï†ú ÏòàÏïΩ Îç∞Ïù¥ÌÑ∞Î°ú Ï≤¥ÌÅ¨)
    const { data: existingReservations } = await supabase
      .from('reservations')
      .select('id')
      .eq('space_id', space_id)
      .not('status', 'eq', 'cancelled')
      .or(`and(start_date.lte.${end_date},end_date.gte.${start_date})`);

    if (existingReservations && existingReservations.length > 0) {
      return NextResponse.json(
        { error: 'Space is already reserved for the selected dates' },
        { status: 409 }
      );
    }

    // Ï¥ù ÎπÑÏö© Í≥ÑÏÇ∞
    const durationDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
    const totalPrice = space.price * durationDays;
    console.log('üí∞ Price calculation:', { durationDays, pricePerDay: space.price, totalPrice });

    // ÏòàÏïΩ ÏÉùÏÑ±
    console.log('üìù Creating reservation...');
    const { data: reservation, error: reservationError } = await supabase
      .from('reservations')
      .insert({
        artist_id: user.id,
        location_id,
        space_id,
        artwork_id,
        start_date,
        end_date,
        status: 'pending',
        total_price: totalPrice,
      })
      .select(`
        *,
        location:locations(*),
        space:spaces(*),
        artwork:artworks(*)
      `)
      .single();

    if (reservationError) {
      console.error('‚ùå Error creating reservation:', reservationError);
      return NextResponse.json(
        { error: 'Failed to create reservation', details: reservationError.message },
        { status: 500 }
      );
    }

    console.log('‚úÖ Reservation created successfully:', reservation?.id);

    // Í≥µÍ∞Ñ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (current_reservations Ï¶ùÍ∞Ä)
    console.log('üîÑ Updating space status...');
    const { data: currentSpace } = await supabase
      .from('spaces')
      .select('current_reservations, max_artworks')
      .eq('id', space_id)
      .single();

    if (currentSpace) {
      const newCount = (currentSpace.current_reservations || 0) + 1;
      await supabase
        .from('spaces')
        .update({ 
          current_reservations: newCount,
          is_reserved: newCount >= currentSpace.max_artworks
        })
        .eq('id', space_id);
    }

    // locationÏùò reserved_slots Ï¶ùÍ∞Ä (ÏÑ†ÌÉùÏÇ¨Ìï≠)
    // ÌòÑÏû¨ Í∞íÏùÑ Í∞ÄÏ†∏ÏôÄÏÑú +1
    const { data: currentLocation } = await supabase
      .from('locations')
      .select('reserved_slots')
      .eq('id', location_id)
      .single();

    if (currentLocation) {
      console.log('üìä Updating location reserved_slots...');
      await supabase
        .from('locations')
        .update({ 
          reserved_slots: (currentLocation.reserved_slots || 0) + 1 
        })
        .eq('id', location_id);
    }

    console.log('üéâ Reservation process completed:', reservation.id);

    return NextResponse.json(
      { 
        success: true,
        message: 'Reservation created successfully',
        reservation 
      },
      { status: 201 }
    );

  } catch (error) {
    console.error('‚ùå POST /api/reservations error:', error);
    console.error('Error details:', {
      message: (error as Error).message,
      stack: (error as Error).stack,
      name: (error as Error).name,
    });
    return NextResponse.json(
      { 
        error: 'Internal server error', 
        details: (error as Error).message 
      },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/reservations/[id]
 * ÏòàÏïΩ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ï∑®ÏÜå, ÌôïÏ†ï Îì±)
 */
export async function PATCH(request: NextRequest) {
  try {
    const supabase = await createClient();
    
    // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©Ïûê ÌôïÏù∏
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' }, 
        { status: 401 }
      );
    }

    const body = await request.json();
    const { reservation_id, status, rejection_reason } = body;

    if (!reservation_id || !status) {
      return NextResponse.json(
        { error: 'Missing required fields: reservation_id, status' },
        { status: 400 }
      );
    }

    // Ïú†Ìö®Ìïú ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
    const validStatuses = ['pending', 'confirmed', 'completed', 'cancelled'];
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` },
        { status: 400 }
      );
    }

    // ÏòàÏïΩ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: reservation, error: fetchError } = await supabase
      .from('reservations')
      .select('*, space_id, location_id, artist_id')
      .eq('id', reservation_id)
      .single();

    if (fetchError || !reservation) {
      return NextResponse.json(
        { error: 'Reservation not found' },
        { status: 404 }
      );
    }

    // Í∂åÌïú ÌôïÏù∏ (ÏòàÏïΩÌïú ÏÇ¨Îûå ÎòêÎäî Ïû•ÏÜå Í¥ÄÎ¶¨ÏûêÎßå ÏàòÏ†ï Í∞ÄÎä•)
    const { data: location } = await supabase
      .from('locations')
      .select('manager_id, name')
      .eq('id', reservation.location_id)
      .single();

    const isOwner = reservation.artist_id === user.id;
    const isManager = location?.manager_id === user.id;

    if (!isOwner && !isManager) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      );
    }

    // ÏòàÏïΩ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    const updateData: any = { 
      status,
      updated_at: new Date().toISOString()
    };
    
    // Í±∞Ï†à Ïãú Í±∞Ï†à ÏÇ¨Ïú† Ï†ÄÏû•
    if (status === 'cancelled' && rejection_reason) {
      updateData.rejection_reason = rejection_reason;
    }
    
    const { data: updatedReservation, error: updateError } = await supabase
      .from('reservations')
      .update(updateData)
      .eq('id', reservation_id)
      .select()
      .single();

    if (updateError) {
      console.error('Error updating reservation:', updateError);
      return NextResponse.json(
        { error: 'Failed to update reservation', details: updateError.message },
        { status: 500 }
      );
    }

    // Ï∑®ÏÜåÎêú Í≤ΩÏö∞ Í≥µÍ∞Ñ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    if (status === 'cancelled') {
      // current_reservations Í∞êÏÜå
      const { data: currentSpace } = await supabase
        .from('spaces')
        .select('current_reservations, max_artworks')
        .eq('id', reservation.space_id)
        .single();

      if (currentSpace && currentSpace.current_reservations > 0) {
        const newCount = currentSpace.current_reservations - 1;
        await supabase
          .from('spaces')
          .update({ 
            current_reservations: newCount,
            is_reserved: newCount >= currentSpace.max_artworks
          })
          .eq('id', reservation.space_id);
      }

      // reserved_slots Í∞êÏÜå
      const { data: currentLocation } = await supabase
        .from('locations')
        .select('reserved_slots')
        .eq('id', reservation.location_id)
        .single();

      if (currentLocation && currentLocation.reserved_slots > 0) {
        await supabase
          .from('locations')
          .update({ 
            reserved_slots: currentLocation.reserved_slots - 1 
          })
          .eq('id', reservation.location_id);
      }
    }

    // ÏïåÎ¶ºÏùÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìä∏Î¶¨Í±∞(notify_artist_on_status_change)ÏóêÏÑú ÏûêÎèôÏúºÎ°ú ÏÉùÏÑ±Îê®
    // Ìä∏Î¶¨Í±∞Îäî ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú ÏûêÎèôÏúºÎ°ú ÏïåÎ¶ºÏùÑ ÏÉùÏÑ±ÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Î≥ÑÎèÑÎ°ú ÏÉùÏÑ±ÌïòÏßÄ ÏïäÏùå
    console.log('üîî Notification will be created by trigger for status:', status);

    console.log('‚úÖ Reservation updated:', reservation_id, status);

    return NextResponse.json({
      success: true,
      message: 'Reservation updated successfully',
      reservation: updatedReservation
    });

  } catch (error) {
    console.error('PATCH /api/reservations error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

